# 线段树模板

```cpp
#include<bits/stdc++.h>
#define int long long
#define maxn 200005

const int INF = 1e18;

using namespace std;

int arr[maxn];

struct SegmentTree {
    long long tree[4 * maxn];
    long long lz[4 * maxn];
    
    void pushdown(int rt, int l, int r) {
        if (lz[rt] == 0 || l == r) return;        
        int mid = (l + r) / 2;
        tree[rt * 2] += lz[rt] * (mid - l + 1);
        lz[rt * 2] += lz[rt];      
        tree[rt * 2 + 1] += lz[rt] * (r - mid);
        lz[rt * 2 + 1] += lz[rt];
        lz[rt] = 0;
    }
    
    void pushup(int rt) {
        tree[rt] = tree[rt * 2] + tree[rt * 2 + 1];
    }

    void build(int rt, int l, int r) {
        lz[rt] = 0;
        if (l == r) {
            tree[rt] = arr[l];
        } else {
            int mid = (l + r) / 2;
            build(rt * 2, l, mid);
            build(rt * 2 + 1, mid + 1, r);
            pushup(rt);
        }
    }

    void update(int rt, int l, int r, int L, int R, int val) {
        if (L <= l && r <= R) {
            tree[rt] += val * (r - l + 1);
            lz[rt] += val;
            return;
        } else if (R < l || L > r) return;
        pushdown(rt, l, r);
        int mid = (l + r) / 2;
        update(rt * 2, l, mid, L, R, val);
        update(rt * 2 + 1, mid + 1, r, L, R, val);
        pushup(rt);
    }

    int query(int rt, int l, int r, int L, int R) {
        if (L <= l && r <= R) {
            return tree[rt];
        } else if (R < l || L > r) return 0;
        pushdown(rt, l, r);
        int mid = (l + r) / 2;
        return query(rt * 2, l, mid, L, R) + query(rt * 2 + 1, mid + 1, r, L, R);
    }
};
```
